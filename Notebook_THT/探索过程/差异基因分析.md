### 差异基因分析和基因集打分       (What)

* Dec 13, 2025                                 (When)
* liyi /data1/liyi/zhaoyue/FUSCC-ESCC-neoadjuvant_thrapy           (Where)
* 主要是对比CD8+T 细胞在Non-MPRvsMPR pre vs post的差异 (Why)

### 导入数据
```python
import scanpy
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
sc.settings.set_figure_params(
    dpi=300,
    facecolor="white",
    frameon=False
)
sc.settings.figdir = "plots"

adata = sc.read("RData/1128_final_escc121.h5ad")
clin_df = pd.read_csv("input/clin_metadata.csv")
```

### 取出CD8子集
```python
cls=['c07_CD8_Tem/Teff_TNFSF9',
     'c08_CD8_Tem/Teff_HSPA1B',
     'c09_CD8_Tem/Teff_GNLY',
     'c10_CD8_Teff_GZMK',
     'c11_CD8_Tex_CXCL13',
     'c12_CD8_Temra_FGFBP2',
     'c13_CD8_IL7R',]
adata_sub = adata[adata.obs['minor_celltype'].isin(cls)].copy()
```

### 得到每个样本的Stage
```python
def get_treatment_stage(sample):
    sample_lower = sample.lower()  # 统一转为小写，避免大小写问题
    if 'prec1' in sample_lower:
        return 'pre'
    elif 'prec2' in sample_lower:
        return 'on'
    elif 'op' in sample_lower:
        return 'post'
    else:
        return 'unknown'  # 处理未匹配到的情况
adata_sub.obs['Stage'] = adata_sub.obs['sample'].apply(get_treatment_stage)
```

### 将疗效信息整合进来
```python
adata_sub.obs['patient'] =adata_sub.obs['sample'].apply(lambda x: '_'.join([x.split('_')[0], x.split('_')[-1]]))
# 有几个患者的住院号是不对的，要调整下
#PDD_2284071应该是PDD_2284017
#ZJM_2306458应该是ZJM_2306548
#YLY_2282682应该是YLY_2286282
replace_map = {
    'PDD_2284071': 'PDD_2284017',
    'ZJM_2306458': 'ZJM_2306548',
    'YLY_2282682': 'YLY_2286282'
}
adata_sub.obs['patient'] = adata_sub.obs['patient'].replace(replace_map)
adata_sub.obs['patient_id'] = adata_sub.obs['patient'].str.split('_').str[-1]
# 4.1 构建patient_id → MPR的映射字典（高效匹配）
clin_df['patient_id'] = clin_df['patient_id'].astype(str).str.strip()
mpr_mapping = dict(zip(clin_df['patient_id'], clin_df['MPR']))
# 4.2 将MPR信息映射到Anndata的obs中
adata_sub.obs['MPR'] = adata_sub.obs['patient_id'].map(mpr_mapping)
```

### 分组进行DEG
```python
def extract_deg_results(adata, group_name='post'):
    """
    从scanpy差异分析结果中提取log2FC、padj等信息，返回DataFrame
    参数：
        adata: 执行rank_genes_groups后的Anndata对象
        group_name: 实验组名称（如post）
    返回：
        deg_df: 包含gene、log2FC、pval、padj的DataFrame
    """
    # 提取原始结果
    deg_dict = adata.uns['deg']
    # 获取所有基因名
    genes = deg_dict['names'][group_name]
    # 提取log2FC（注意：scanpy中logfoldchanges对应log2FC）
    log2fc = deg_dict['logfoldchanges'][group_name]
    # 提取原始p值和校正后p值
    pval = deg_dict['pvals'][group_name]
    padj = deg_dict['pvals_adj'][group_name]
    # 提取pct
    pct = deg_dict['pts'][group_name]

    # 构建DataFrame
    deg_df = pd.DataFrame({
        'gene': genes,
        'log2FC': log2fc,
        'pval': pval,
        'padj': padj,
        'pct':pct
    })

    # 处理NaN值（如无差异的基因）
    deg_df = deg_df.fillna({'padj': 1.0, 'pval': 1.0, 'log2FC': 0.0})
    # 按padj排序（显著基因在前）
    deg_df = deg_df.sort_values('padj', ascending=True)

    return deg_df

### MPR-post vs pre
adata_MPR = adata_sub[adata_sub.obs['MPR']==1 & adata_sub.obs['Stage'].isin(["pre","post"]),~(adata_sub.var['mt'] | adata_sub.var['ribo'] | adata_sub.var['hb'])].copy()
sc.tl.rank_genes_groups(
    adata_MPR,
    groupby='Stage',          # 按Stage分组
    reference='pre',          # 对照组：pre
    method='t-test',        # 单细胞推荐用wilcoxon（秩和检验）
    key_added="deg",
    pts = True,
)
deg_df = extract_deg_results(adata_MPR, group_name='post')
deg_df.to_csv("output/MPR_post_vs_pre_deg_results.csv", index=False)

### Non-MPR-post vs pre
adata_NonMPR = adata_sub[adata_sub.obs['MPR']==0 & adata_sub.obs['Stage'].isin(["pre","post"])].copy()
sc.tl.rank_genes_groups(
    adata_NonMPR,
    groupby='Stage',          # 按Stage分组
    reference='pre',          # 对照组：pre
    method='wilcoxon',        # 单细胞推荐用wilcoxon（秩和检验）
    key_added="deg"
)
deg_df = extract_deg_results(adata_NonMPR, group_name='post')
deg_df.to_csv("output/NonMPR_post_vs_pre_deg_results.csv", index=False)

### Pre-MPR vs Non-MPR
adata_pre = adata_sub[(adata_sub.obs['Stage']=="pre") & (adata_sub.obs['MPR'].isin([0,1]))].copy()
adata_pre.obs['Response'] = adata_pre.obs['MPR'].apply(lambda x: "MPR" if x == 1 else ("Non-MPR" if x == 0 else np.nan))
sc.tl.rank_genes_groups(
    adata_pre,
    groupby='Response',          # 按疗效分组
    reference='Non-MPR',          # 对照组：Non-MPR
    method='wilcoxon',        # 单细胞推荐用wilcoxon（秩和检验）
    key_added="deg"
)
deg_df = extract_deg_results(adata_pre, group_name='MPR')
deg_df.to_csv("output/Pre_MPR_vs_nonMPR_deg_results.csv", index=False)

### Post-MPR vs Non-MPR
adata_post = adata_sub[(adata_sub.obs['Stage']=="post") & (adata_sub.obs['MPR'].isin([0,1]))].copy()
adata_post.obs['Response'] = adata_post.obs['MPR'].apply(lambda x: "MPR" if x == 1 else ("Non-MPR" if x == 0 else np.nan))
sc.tl.rank_genes_groups(
    adata_post,
    groupby='Response',          # 按疗效分组
    reference='Non-MPR',          # 对照组：Non-MPR
    method='wilcoxon',        # 单细胞推荐用wilcoxon（秩和检验）
    key_added="deg"
)
deg_df = extract_deg_results(adata_post, group_name='MPR')
deg_df.to_csv("output/Post_MPR_vs_nonMPR_deg_results.csv", index=False)
```

### 打分(基因集来自张泽民)
```python
exhaustion_geneset=["HAVCR2","ENTPD1","LAYN","LAG3"]
cytotoxity_geneset=["PRF1","GZMB","GZMA","GZMH","NKG7","GNLY"]
sc.tl.score_genes(
    adata_sub,
    gene_list=exhaustion_geneset,
    score_name='exhaustion_score',
    )
sc.tl.score_genes(
    adata_sub,
    gene_list=cytotoxity_geneset,
    score_name='cytotoxity_score',
)
# 绘制小提琴图-耗竭
# ===================== 1. 定义核心配置 =====================
# 1.1 分组-颜色映射（原完整分组名 → 颜色）
color_map = {
    'c07_CD8_Tem/Teff_TNFSF9': '#F2D7D0',
    'c08_CD8_Tem/Teff_HSPA1B': '#E8A7BA',
    'c09_CD8_Tem/Teff_GNLY': '#8A7FA0',
    'c10_CD8_Teff_GZMK': '#F4EFA9',
    'c11_CD8_Tex_CXCL13': '#E77772',
    'c12_CD8_Temra_FGFBP2': '#4D4199',
    'c13_CD8_IL7R': '#F1B9AE'
}
# 1.2 自定义X轴短标签（与分组一一对应）
custom_xticks = ['c07', 'c08', 'c09', 'c10', 'c11', 'c12', 'c13']
# 1.3 提取分组顺序（确保颜色/标签顺序一致）
group_order = list(color_map.keys())

# ===================== 2. 绘制小提琴图（核心：移除散点） =====================
ax = sc.pl.violin(
    adata_sub,
    keys="exhaustion_score",
    groupby="minor_celltype",
    jitter=False,        # 关闭散点抖动（基础）
    stripplot=False,     # 核心：完全移除小提琴上的散点
    log=False,
    cut=0,
    rotation=90,         # 先设90度，后续自定义标签时覆盖
    ylabel="Exhaustion score",
    show=False,
    order=group_order,   # 强制分组顺序与颜色/标签匹配
    palette=color_map,   # 应用自定义填充色
    linewidth=0.5,         # 隐藏小提琴边框
    inner='box',          # 移除内部箱线（可选，如需保留设为'box'）
)

# ===================== 3. 样式调整 =====================
# 3.1 移除Y轴网格线 + 确保小提琴无边框
ax.yaxis.grid(False)  # 移除Y轴网格
for pc in ax.collections:
    pc.set_edgecolor('none')  # 移除填充区边框
    pc.set_linewidth(0)

# 3.2 自定义X轴标签（替换为c07-c13）+ 匹配填充色
# 获取原X轴位置（与分组一一对应）
x_pos = range(len(custom_xticks))
# 设置新标签
ax.set_xticks(x_pos)
ax.set_xticklabels(
    custom_xticks,  # 替换为短标签
    fontsize=12,
    rotation=90,    # 旋转45度更易读
    ha='right',     # 右对齐避免截断
    fontweight='bold'
)

# 3.3 逐个设置X轴标签颜色（与对应小提琴填充色一致）
for i, (tick_label, color) in enumerate(zip(ax.get_xticklabels(), color_map.values())):
    tick_label.set_color(color)  # 标签颜色=对应分组的填充色

# 3.4 Y轴样式（保留原有设置）
ax.set_yticklabels(
    ax.get_yticklabels(),
    fontsize=8,
    fontweight='bold'
)
ax.set_ylabel('Exhaustion score', fontsize=14)

# ===================== 4. 布局与保存/显示 =====================
plt.tight_layout()
plt.savefig("plots/violin_exhaustion_score.png", dpi=300, bbox_inches='tight')
plt.show()

# 绘制小提琴图-杀伤
# ===================== 1. 定义核心配置 =====================
# 1.1 分组-颜色映射（原完整分组名 → 颜色）
color_map = {
    'c07_CD8_Tem/Teff_TNFSF9': '#F2D7D0',
    'c08_CD8_Tem/Teff_HSPA1B': '#E8A7BA',
    'c09_CD8_Tem/Teff_GNLY': '#8A7FA0',
    'c10_CD8_Teff_GZMK': '#F4EFA9',
    'c11_CD8_Tex_CXCL13': '#E77772',
    'c12_CD8_Temra_FGFBP2': '#4D4199',
    'c13_CD8_IL7R': '#F1B9AE'
}
# 1.2 自定义X轴短标签（与分组一一对应）
custom_xticks = ['c07', 'c08', 'c09', 'c10', 'c11', 'c12', 'c13']
# 1.3 提取分组顺序（确保颜色/标签顺序一致）
group_order = list(color_map.keys())

# ===================== 2. 绘制小提琴图（核心：移除散点） =====================
ax = sc.pl.violin(
    adata_sub,
    keys="cytotoxity_score",
    groupby="minor_celltype",
    jitter=False,        # 关闭散点抖动（基础）
    stripplot=False,     # 核心：完全移除小提琴上的散点
    log=False,
    cut=0,
    rotation=90,         # 先设90度，后续自定义标签时覆盖
    ylabel="Cytotoxity score",
    show=False,
    order=group_order,   # 强制分组顺序与颜色/标签匹配
    palette=color_map,   # 应用自定义填充色
    linewidth=0.5,         # 隐藏小提琴边框
    inner='box',          # 移除内部箱线（可选，如需保留设为'box'）
)

# ===================== 3. 样式调整 =====================
# 3.1 移除Y轴网格线 + 确保小提琴无边框
ax.yaxis.grid(False)  # 移除Y轴网格
for pc in ax.collections:
    pc.set_edgecolor('none')  # 移除填充区边框
    pc.set_linewidth(0)

# 3.2 自定义X轴标签（替换为c07-c13）+ 匹配填充色
# 获取原X轴位置（与分组一一对应）
x_pos = range(len(custom_xticks))
# 设置新标签
ax.set_xticks(x_pos)
ax.set_xticklabels(
    custom_xticks,  # 替换为短标签
    fontsize=12,
    rotation=90,    # 旋转45度更易读
    ha='right',     # 右对齐避免截断
    fontweight='bold'
)

# 3.3 逐个设置X轴标签颜色（与对应小提琴填充色一致）
for i, (tick_label, color) in enumerate(zip(ax.get_xticklabels(), color_map.values())):
    tick_label.set_color(color)  # 标签颜色=对应分组的填充色

# 3.4 Y轴样式（保留原有设置）
ax.set_yticklabels(
    ax.get_yticklabels(),
    fontsize=8,
    fontweight='bold'
)
ax.set_ylabel('Cytotoxity score', fontsize=14)

# ===================== 4. 布局与保存/显示 =====================
plt.tight_layout()
plt.savefig("plots/violin_cytotoxity_score.png", dpi=300, bbox_inches='tight')
plt.show()
```
